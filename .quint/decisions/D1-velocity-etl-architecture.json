{
  "id": "D1",
  "title": "Use Traditional Normalized ETL for Velocity Data Centralization",
  "winner_id": "H1",
  "decision_timestamp": "2025-12-27T04:45:00Z",
  "decider": "claude-code",
  "status": "ACCEPTED",

  "context": {
    "problem": "Velocity API returns deeply nested JSON data for mortgage deals. Need to centralize data from 40 brokers into Supabase PostgreSQL for proposal generation, reporting, and future features like property equity watchers.",
    "domain": "Mortgage Brokerage Data Management",
    "constraints": [
      "Must use Supabase PostgreSQL as target database",
      "Must use TypeScript/Node.js for sync scripts",
      "Each broker has unique API key",
      "Data must support efficient querying for HOLP proposal generation",
      "Must handle ~10,000+ deals across all brokers"
    ],
    "alternatives_considered": [
      {"id": "H1", "title": "Traditional Normalized ETL", "status": "SELECTED"},
      {"id": "H2", "title": "JSONB Storage with Views", "status": "DEFERRED"},
      {"id": "H3", "title": "Hybrid: Core Normalized + JSONB", "status": "DEFERRED"},
      {"id": "H4", "title": "Supabase Edge Functions + Realtime", "status": "REJECTED"}
    ]
  },

  "decision": "We decided to use Traditional Normalized ETL (H1) because it passed both logical deduction and empirical validation with 100% sync success across 17 brokers and 10,000+ deals.",

  "rationale": {
    "r_eff": 0.90,
    "confidence": "HIGH",
    "evidence_cited": [
      "E1: API Data Structure Analysis confirmed consistent data patterns across brokers",
      "E2: Q3 Full Sync Validation achieved 100% success rate (261 failures reduced to 0)"
    ],
    "key_factors": [
      "Strong data integrity via FK constraints",
      "Efficient JOINs for proposal generation queries",
      "Clear schema documentation for future developers",
      "Proven, well-understood ETL pattern reduces risk"
    ],
    "why_not_others": {
      "H2_JSONB": "Conditional - deferred for future consideration if query patterns become unpredictable",
      "H3_Hybrid": "Conditional - may revisit if performance issues arise with full normalization",
      "H4_Edge": "Rejected - edge functions add latency and complexity without clear benefit for batch sync"
    }
  },

  "consequences": {
    "immediate": [
      "Schema is deployed with 15 lookup tables + 12 main tables",
      "Sync API operational at /api/sync",
      "17 brokers synced successfully"
    ],
    "trade_offs": [
      "Schema changes require migrations (acceptable for stable Velocity API)",
      "Complex transformer code (mitigated by TypeScript type safety)",
      "More tables to manage (offset by clear structure)"
    ],
    "next_steps": [
      "Sync remaining 23 brokers",
      "Implement cron job for continuous sync (every 15 min)",
      "Build proposal PDF generation using centralized data",
      "Add monitoring for sync failures"
    ],
    "technical_debt": [
      "Some enum codes may be undiscovered - add fallback handling",
      "Error retry logic could be enhanced with exponential backoff"
    ]
  },

  "validity": {
    "revisit_when": [
      "Query patterns become unpredictable (consider H2/H3)",
      "Schema changes become frequent (>monthly)",
      "Performance degrades with >100k deals"
    ],
    "expiry": "2026-12-27",
    "review_trigger": "Major Velocity API version change"
  },

  "characteristics": {
    "data_integrity": "A",
    "query_performance": "A",
    "schema_flexibility": "C",
    "implementation_complexity": "B",
    "maintenance_cost": "B"
  },

  "audit_reference": "A1",
  "hypothesis_reference": "H1",
  "evidence_references": ["E1", "E2"]
}
